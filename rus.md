# После… или нет, ::before… нужно разобраться…

![css][css]

Когда старенький JS-разработчик копается в CSS чтобы написать статью вроде этой, 
это наверное выглядит странно? :)

Я здесь немного поразглагольствую. Думаю многие со мной согласятся что ту 
ситуацию, к которой мы пришли, иначе как косяком не назовёшь. 

## Псевдо-CSS

Слышали ли вы о [псевдоэлементах CSS][1] `::before` и `::after`? Если нет, или 
же вы пока не очень близко с ними знакомы, давайте разберёмся что это за звери.

«Псевдо» первым делом говорит о том, что они скорее «виртуальные» чем «реальные». 
Они придуманы чтобы позволить нам с помощью CSS стилизировать особый тип 
элементов, которые *на самом деле* непосредственно в разметке отсутствуют. Эти 
особенные элементы являются виртуальной частью документа, хотя напрямую в 
структуре документа и не представлены. 

С помощью `::after` и `::before` мы обращаемся к «последнему дочернему элементу» 
или «первому дочернему элементу» контейнера, для которого применено 
соответствующее стилевое правило. Нет, не к настоящему первому или последнему 
дочернему элементу, а к вымышленному, который существует только если вы 
прописываете для него стилевые свойства, в противном случае он — всего лишь 
латентный призрак.

Пример: 

    <style>
    #container { background-color:yellow; }
    #container::before { content:"!!!!! "; font-style:italic; }
    #container::after { content:"!!!!!"; font-weight:bold; }
    </style>
 
    <div id="container">В этом контейнере есть не только этот текст</div>

<style>
#container_ex1_inline::before { content:"!!!!!"; font-style:italic; }
#container_ex1_inline::after { content:"!!!!!"; font-weight:bold; }
</style>
<p id="container_ex1_inline" style="background-color: yellow;">В этом контейнере есть не только этот текст</p>

Круто, да?

Предназначением правила `content` в псевдоэлементах является добавление 
визуально-декоративных элементов с помощью CSS с целью избежать загромождения 
разметки элементами представления. Например, оно позволяет добавить после ссылок 
иконки, обозначающие что эти ссылки являются внешними, или же стилизированные 
кавычки вокруг блочной цитаты `blockquote` и т.д.

**Примечание:** Вы можете встретить два вида записи: `::after` или `:after`. С 
технической точки зрения для псевдо-элементов и псевдо-селекторов вместо `:` 
нужно использовать `::`. В большинстве браузеров оба варианта работают. Здесь я 
использую запись `::`, ведь за ней будущее!

## «after» — после чего?

Если приглядеться внимательней, у `::before` и `::after` странная семантика. 
Если вы следите за моими заметками на тему CSS, думаю вы заметили что я вообще 
[очень серьёзно отношусь к вопросу семантики в CSS][2].

Видя слова «before» («перед») и «after» («после») большинство людей понимает что 
добавленный контент должен отображаться чётко перед или после элемента с 
соответствующим стилевым правилом. То есть, что они должны быть элементами 
одного уровня с нашим контейнером. 

Однако на самом деле мы прописываем стилевые правила для дочерних элементов 
нашего контейнера, элементов, которые в нём виртуально расположены в самом 
начале и в конце. 

Вот именно, в этом случае «after» не значит «после», оно значит «последний 
дочерний элемент». **Глубокий вздох.** Вот вам и семантический косяк. Они не 
такая уж редкость.

В мире JS уже есть устоявшийся прецедент добавления дочерних элементов в начало 
элемента-контейнера перед остальными дочерними элементами или в конец после всех 
остальных. В мире JS фреймворков (jQuery и др.) и даже во встроенном нативном 
DOM API мы вызываем нечто вроде `parent.appendChild(child)` для дополнения 
списка дочерних элементов в родительском контейнере. Возможно с точки зрения 
семантики было бы лучше если бы в CSS вместо `::after` использовалось `::append` 
или `::append-child`.

Как насчёт `::before`? Что ж, в самом DOM API нет такого метода как 
`prependChild()`, так что нам придётся пойти кружным путём и использовать 
`parent.insertBefore(child,parent.firstChild)`. Тьфу. К счастью, в фреймворках 
JS для таких случаев реализован метод `prepend()`. Так и в CSS лучшим аналогом 
было бы использовать псевдо-элемент `::prepend` или `::prepend-child`.

## `::повторение-ошибок:no`

Все эти семантические недоразумения в CSS удручают, даже не столько каждый 
отдельный случай, сколько в общем тот факт что они встречаются сплошь и рядом. 
Однако видимо такова жизнь веб-разработчика.

Тем не менее, я думаю что если мы будем постоянно обращать внимание на такие 
*ошибки*, может быть со временем нам удастся уменьшить их количество. Очень 
надеюсь.

Что думаете вы? Было ли правильным в CSS назвать псевдо-элемент `::after`? Или 
лучше было бы использовать более семантическое обозначение `::append` и отнести 
раскритикованный вариант в список устаревших? Или же мне просто стоит 
`::смириться-и-жить-дальше`?

[1]: https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements
[2]: http://blog.getify.com/html-vs-css-semantics/

[css]: img/shutterstock_145488154-660x380.jpg